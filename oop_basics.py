# Объектно-ориентированное программирование
# ООП - это способ организации программы, позволяющий использовать один и тот же код многократно.
# В отличие от функций и модулей, ООП позволяет не только разделить программу на фрагменты, но и
# описать предметы реального мира в виде удобных сущностей - объектов, а также организовать
# связи между этими объектами.

# Основным "кирпичиком" ООП является КЛАСС - сложный тип данных, включающий набор переменных
# и функций для управления значениями, хранящимися в этих переменных. Переменные называют
# атрибутами или свойствами, а функции - методами. КЛАСС является фабрикой объектов, то есть
# позволяет создать неограниченное количество экземпляров, основанных на этом классе.

# Определение класса и создание экземпляра класса
# Класс описывается с помощью ключевого слова class

# class <Название класса>[(<Класс1>[, ..., <КлассN>])]:
#     [""" Строка документирования """]
#     <Описание атрибутов и методов>

# Следует заметить, что все выражения внутри инструкции class выполняются при создании класса,
# а не его экземпляра

class MyClass:
    """ Это строка документирования """
    print("Инструкция выполняется сразу")


# >> 'Инструкция выполняется сразу'

# Чтобы использовать атрибуты и методы класса, необходимо создать экземпляр класса,
# согласно следующему синтаксису:

# <Экземпляр класса> = <Название класса>([Параметры])

# При обращении к методам класса используется такой формат:

# <Экземпляр класса>.<Имя метода>([Параметры])

# Обращение к атрибутам класса осуществляется аналогично

# <Экземпляр класса>.<Имя атрибута>

class MyClass:
    def __init__(self):  # Конструктор
        self.x = 10  # Атрибут экземпляра класса

    def print_x(self):  # self - это ссылка на экземпляр класса
        print(self.x)  # выводим значение атрибута


c = MyClass()  # создание экземпляра класса
c.print_x()  # self не указывается при вызове метода
print(c.x)  # К атрибуту можно обратиться непосредственно


# Для доступа к атрибутам и методам можно использовать следующие функции:
# getattr() - возвращает значение атрибута по его названию, заданному в виде строки.
# С помощью этой функции можно сформировать имя атрибута динамически во время выполнения программы
# getattr(<Объект>, <Атрибут>[, <Значение по умолчанию>])
# Если указанный атрибут не найден, возбуждается исключение AttributeError. Чтобы избежать
# вывода сообщения об ошибке, в третьем параметре можно указать значение, которое будет
# возвращаться, если атрибут не существует

# setattr() - задает значение атрибута. Название атрибута указывается в виде строки.
# setattr(<Объект>, <Атрибут>, <Значение>)
# Вторым параметром функции setattr() можно передать имя несуществующего атрибута -
# - в этом случае атрибут с указанным именем будет создан.

# delattr(<Объект>, <Атрибут>) - удаляет атрибут, чье название указано в виде строки

# hasattr(<Объект>, <Атрибут>) - проверяет наличие указанного атрибута. Если атрибут
# существует, функция возвращает True

class MyClass:
    def __init__(self):
        self.x = 'Десять'

    def get_x(self):
        return self.x


c = MyClass()  # Создаем экземпляр класса
print(getattr(c, 'x'))  # >> 'Десять'
print(getattr(c, 'get_x')())  # >> 'Десять'
print(getattr(c, 'y', 'Ноль'))  # >> 'Ноль' - т. к. атрибут y не найден
setattr(c, 'y', 'Пять')  # Создаем атрибут y
print(getattr(c, 'y', 'Ноль'))  # >> 'Пять'
delattr(c, 'y')  # Удаляем атрибут y
print(getattr(c, 'y', 'Ноль'))  # 'Ноль'
print(hasattr(c, 'x'))  # >> True
print(hasattr(c, 'y'))  # >> False


# Атрибуты допускается создавать динамически после создания класса - можно создать
# как атрибут объекта класса, так и атрибут экземпляра класса.

class MyClass:  # Определяем пустой класс
    pass


MyClass.x = 50  # Создаем атрибут объекта класса
# Атрибут x будет доступен всем создаваемым экземплярам класса
c1, c2 = MyClass(), MyClass()  # Создаем два экземпляра объекта класса
c1.y = 10  # Создаем атрибут экземпляра класса
c2.y = 20  # Создаем атрибут экземпляра класса
print(c1.x, c1.y)
print(c2.x, c2.y)


# Если создать новый экземпляр класса (например, c3), то атрибут y в нем определен не будет.

# АТРИБУТ ОБЪЕКТА КЛАССА доступен всем экземплярам класса, а после изменения значения атрибута
# значение изменится во всех экземплярах класса.
# АТРИБУТ ЭКЗЕМПЛЯРА КЛАССА может хранить уникальное значение для каждого экземпляра, и изменение
# его в одном экземпляре не затронет значения одноименного атрибута в других экземплярах того
# же класса.

class MyClass:
    x = 10  # Атрибут объекта класса

    def __init__(self):
        self.y = 20  # Атрибут экземпляра класса


c1 = MyClass()  # Создаем экземпляр класса
c2 = MyClass()  # Создаем экземпляр класса
print(c1.x, c2.x)  # >> 10 10
MyClass.x = 88  # Изменим атрибут объекта класса
print(c1.x, c2.x)  # >> 88 88
# Изменение атрибута класса затронуло значение в двух экземплярах класса сразу.

print(c1.y, c2.y)  # >> 20 20
c1.y = 88
print(c1.y, c2.y)  # >> 88 20
# В этом случае изменилось значение атрибута в экземпляре c1

# Следует также учитывать, что в одном классе могут одновременно существовать атрибут
# объекта и атрибут экземпляра класса с одним именем
MyClass.x = 99  # Изменили атрибут объекта класса
c1.x = 200  # СОЗДАЕМ АТРИБУТ ЭКЗЕМПЛЯРА
print(c1.x, MyClass.x)


# Методы __init__() и __del__()
# При создании экземпляра класса интерпретатор автоматически вызывает метод инициализации
# __init__(). В других языках программирования такой метод принято называть
# КОНСТРУКТОРОМ КЛАССА.

# def __init__(self[, <Значение1>[, ..., <ЗначениеN>]]):
#     <Инструкции>

# С помощью метода __init__() атрибутам класса можно присвоить начальные значения.
# При создании экземпляра класса параметры этого метода указываются после изменения класса
# в круглых скобках

# <Экземпляр класса> = <Имя класса>([<Значение1>[, ..., <ЗначениеN>]])

class MyClass:
    def __init__(self, value1, value2):  # Конструктор
        self.x = value1
        self.y = value2


c = MyClass(100, 300)  # Создаем экземпляр класса
print(c.x, c.y)  # >> 100 300


# Если конструктор вызывается при создании экземпляра, то перед уничтожением экземпляра
# автоматически вызывается метод, называемый ДЕСТРУКТОРОМ.
# ДЕСТРУКТОР реализуется в виде предопределенного метода __del__().
# Поскольку интерпретатор самостоятельно заботится об удалении объектов, использование
# деструктора не имеет особого смысла
class MyClass:
    def __init__(self):  # Конструктор класса
        print('Вызван метод __init__()')

    def __del__(self):  # Деструктор класса
        print('Вызван метод __del__()')


# с1 = MyClass()
# del c1
# c2 = MyClass()
# c3 = c2
# del c2
# del c3


# НАСЛЕДОВАНИЕ является, пожалуй главным понятием ООП. Например, у нас есть Class1.
# При помощи наследования мы можем создать новый класс Class2, в котором будет
# реализован доступ ко всем атрибутам и методам класса Class1

class Class1:  # Базовый класс
    def func1(self):
        print('Метод func1() класса Class1')

    def func2(self):
        print('Метод func2() класса Class1')


class Class2(Class1):  # Класс Class2 наследует класс Class1
    def func3(self):
        print('Метод func3() класса Class2')


c = Class2()  # Создаем экземпляр класса Class2
c.func1()  # Выведет Метод func1() класса Class1
c.func2()  # Выведет Метод func2() класса Class1
c.func3()  # Выведет Метод func3() класса Class2


# Как видно, Class1 указывается внутри круглых скобок в определинии класса Class2.
# Таким образом, Class2 наследует все атрибуты и методы класса Class1.
# Класс Class1 называется БАЗОВЫМ или СУПЕРКЛАССОМ, а класс Class2 - ПРОИЗВОДНЫМ или ПОДКЛАССОМ

# Если имя метода в классе Class2 совпадает с именем метода класса Class1, то будет использоваться
# метод из класса Class2. Чтобы вызвать одноименный метод из базового класса, перед методом
# следует через точку написать название базового класса, а в первом параметре метода -
# - явно указать ссылку на экземпляр класса

class Class1:  # Базовый класс
    def __init__(self):
        print('Конструктор базового класса')

    def func1(self):
        print('Метод func1() класса Class1')


class Class2(Class1):  # Класс Class2 наследует класс Class1
    def __init__(self):
        print('Конструктор производного класса')
        Class1.__init__(self)  # Вызываем конструктор базового класса

    def func1(self):
        print('Метод func1() класса Class2')
        Class1.func1(self)  # вызываем метод базового класса


c = Class2()  # Создаем экземпляр класса Class2
c.func1()  # Вызываем метод func1()


# ВНИМАНИЕ! Конструктор базового класса автоматически не вызывается, если он переопределен
# в производном классе

# С помощью функции super() инструкцию
# Class1.__init__(self) Вызываем конструктор базового класса
# # можно записать так
# super().__init__() Вызываем конструктор базового класса
# # или так
# super(Class2, self).__init__() Вызываем конструктор базового класса

# При использовании функции super() не нужно явно передавать указатель self в вызываемый
# метод. Кроме того, в первом параметре функции super() указывается производный класс,
# а не базовый. Поиск идентификатора будет производиться во всех базовых классах.

# Множественное наследование
# В определении класса в круглых скобках можно указать сразу несколько базовых классов
# через запятую.
class Class1:  # Базовый класс для класса CLass2
    def func(self):
        print('Метод func1() класса Class1')


class Class2(Class1):  # Класс Class2 наследует класс Class1
    def func2(self):
        print('Метод func2() класса Class2')


class Class3(Class1):  # Класс Class3 наследует Class1
    def func1(self):
        print('Метод func1() класса Class3')

    def func2(self):
        print('Метод func2() класса Class3')

    def func3(self):
        print('Метод func3() класса Class3')

    def func4(self):
        print('Метод func4() класса Class3')


class Class4(Class2, Class3):  # Множественное наследование
    def func4(self):
        print('Метод func4() класса Class4')


c = Class4()  # Создаем экземпляр класса Class4
c.func1()  # Метод func1() класса Class3
c.func2()  # Метод func2() класса Class2
c.func3()  # Метод func3() класса Class3
c.func4()  # Метод func4() класса Class4

# Для получения перечня базовых классов можно воспользоваться атрибутом __bases__
# В качестве значения атрибут возвращает кортеж.
print(Class1.__bases__)
print(Class2.__bases__)
print(Class3.__bases__)
print(Class4.__bases__)


# Рассмотрим порядок поиска идентификаторов при сложной иерархии множественного наследования
class Class1: x = 10


class Class2(Class1): pass


class Class3(Class2): pass


class Class4(Class3): pass


class Class5(Class2): pass


class Class6(Class5): pass


class Class7(Class4, Class6): pass


c = Class7()
print(c.x)
# Последовательность поиска атрибута x будет такой
# Class7 -> Class4 -> Class3 -> Class6 -> Class5 -> Class2 -> Class1
# Получить всю цепочку наследования позволяет атрибут __mro__
print(Class7.__mro__)


# Примеси и их использование
# Множественное наследование, позволяет реализовать интересный способ расширения
# функциональности классов с помощью так называемых ПРИМЕСЕЙ (mixins).
# Примесь - это класс, включающий какие-либо атрибуты и методы, которые
# необходимо добавить к другим классам. Объявляются они так же, как и обычные классы

class Mixin:  # Определяем сам класс-примесь
    attr = 0  # Определяем атрибут примеси

    def mixin_method(self):  # Определяем метод примеси
        print('Метод примеси')


class Class1(Mixin):
    def method1(self):
        print('Метод класса Class1')


class Class2(Class1, Mixin):
    def method2(self):
        print('Метод класса Class2')


c1 = Class1()
c1.method1()
c1.mixin_method()  # Class1 поддерживает метод примеси

c2 = Class2()
c2.method1()
c2.method2()
c2.mixin_method()  # Class2 поддерживает метод примеси


# Специальные методы
# Классы поддерживают следующие специальные методы:
# __call__() - позволяет обработать вызов экземпляра класса как вызов функции
# __call__(self[, <Параметр1>[, ..., <ПараметрN>]])
class MyClass:
    def __init__(self, m):
        self.msg = m

    def __call__(self):
        print(self.msg)


c1 = MyClass('Значение1')
c2 = MyClass('Значение2')  # Создание экземпляра класса
c1()  # Вызов экземпляра функции
c2()


# __getattr__(self, <Атрибут>) - вызывается при обращении к несуществующему атрибуту
class MyClass:
    def __init__(self):
        self.i = 20

    def __getattr__(self, item):
        print('Вызван метод __getattr__()')
        return 0


c = MyClass()
# Атрибут i существует
print(c.i)  # Выведет 20. Метод __getattr__() не вызывается
# Атрибут s не существует
print(c.s)  # Выведет Вызван метод __getattr__() 0


# __getattribute__(self, <Атрибут>) - вызывается при обращении к любому атрибуту класса.
# Необходимо учитывать, что использование точечной нотации (для обращения к атрибуту класса)
# внутри этого метода приведет к зацикливанию. Чтобы избежать зацикливая, следует вызвать
# метод __getattribute__() объекта object и внутри этого метода вернуть значение атрибута
# или возбудить исключение AttributeError
class MyClass:
    def __init__(self):
        self.i = 20

    def __getattribute__(self, attr):
        print('Вызван метод __getattribute__()')
        return object.__getattribute__(self, attr)  # Только так!!!


c = MyClass()
print(c.i)


# __setattr__(self, <Атрибут>, <Значение>) - вызывается при попытке приваивания значения
# атрибуту экземпляра класса. Если внутри метода необходимо присвоить значение атрибуту,
# следует использовать словарь __dict__, поскольку при применении точечной нотации метод
# __setattr__() будет вызван повторно, что приведет к зацикливанию
class MyClass:
    def __setattr__(self, attr, value):
        print('Вызван метод __setattr__()')
        self.__dict__[attr] = value  # Только так!!!


c = MyClass()
c.i = 10  # >> Вызван метод __setattr__()
print(c.i)  # >> 10


# __delattr__(self, <Атрибут>) - вызывается при удалении атрибута с помощью инструкции
# del <Экземпляр класса>.<Атрибут>

# __len__(self) - вызывается при использовании функции len(), а также для проверки объекта
# на логическое значение при отсутствии метода __bool__().
# Метод должен возвращать положительное число
class MyClass:
    def __len__(self):
        return 50


c = MyClass()
print(len(c))


# __bool__(self) - вызывается при использовании функции bool()
# __int__(self) - вызывается при преобразовании объекта в целое число с помощью ф-ции int()
# __float__(self) - вызывается при преобразовании объекта в вещественное число с помощью ф-ции float()
# __complex__(self) - вызывается при преобразовании объекта в комплексное число с помощью ф-ции complex()
# __round__(self) - вызывается при использовании функции round()
# __index__(self) - вызывается при использовании функций bin(), hex(), oct()

# __repr__(self) и __str__(self) - служат для преобразования объекта в строку. Метод
# __repr__() вызывается при выводе в интерактивной оболочке, а также при использовании
# функции repr(). Метод __str__() вызывается при выводе с помощью функции print(),
# а также при использовании функции str(). Если метод __str__() отсутствует, будет
# вызван метод __repr__(). В качестве значения методы __repr__() и __str__() возвращают строку
class MyClass:
    def __init__(self, m):
        self.msg = m

    def __repr__(self):
        return 'Вызван метод __repr__() {0}'.format(self.msg)

    def __str__(self):
        return 'Вызван метод __str__() {0}'.format(self.msg)


c = MyClass('Значение')
print(repr(c))
print(str(c))
print(c)


# __hash__(self) - этот метод следует переопределить, если экземпляр класса
# планируется использовать в качестве ключа словаря или внутри множества
class MyClass:
    def __init__(self, y):
        self.x = y

    def __hash__(self):
        return hash(self.x)


c = MyClass(10)
d = {}
d[c] = 'Значение'
print(d[c])
print(d)


# Перегрузка операторов позволяет экземплярам классов участвовать в обычных операциях.
# Чтобы перезагрузить оператор, необходимо в классе определить метод со специальным названием
# Небольшой пример методов
# x + y - x.__add__(y)
# x - y - x.__sub__(y)
# x * y - x.__mul__(y)
# x / y - x.__truediv__(y)
# x // y - x.__floordiv__(y)
# x % y - x.__mod__(y)
# x ** y - x.__pow__(y)
# -x - унарный минус: x.__neg__()
# +x - унарный плюс: x.__pos__()
# abs(x) -- x.__abs__()
# Если значение необходимо посчитать и присвоить то слева от метода необходимо
# добавить символ i, например __iadd__(), __isub__(), __imul__() и т.д.
# Если экземпляр класса находится справа в выражении, то есть y + c.x, тогда
# необходимо добавить слева символ r, например __radd__(), __rsub__(), __rmul__()

class MyClass:
    def __init__(self, y):
        self.x = y

    def __add__(self, y):  # Перегрузка оператора +
        print("Экземпляр слева")
        return self.x + y

    def __radd__(self, y):  # Перегрузка оператора +
        print("Экземпляр справа")
        return self.x + y

    def __iadd__(self, y):  # Перегрузка оператора +=
        print("Сложение с присваиванием")
        self.x += y
        return self


c = MyClass(50)
print(c + 10)
print(20 + c)
c += 30
print(c.x)


# Статические методы и методы класса
# Внутри класса можно создать метод, который будет доступен
# без создания экземпляра класса (статический метод).
# Для этого внутри класса следует указать декоратор @staticmethod

# <Название класса>.<Название метода>(<Параметры>)

# Кроме того можно вызвать статический метод, через экземпляр класса

# <Экземпляр класса>.<Название метода>(<Параметры>)

class MyClass:
    @staticmethod
    def func1(x, y):  # Статический метод
        return x + y

    def func2(self, x, y):  # Обычный метод в классе
        return x + y

    def func3(self, x, y):
        return MyClass.func1(x, y)  # Вызов метода из класса


print(MyClass.func1(10, 20))  # Вызываем статический метод
c = MyClass()
print(c.func2(5, 19))  # Вызываем метод класса
print(c.func1(50, 12))  # Вызываем статический метод через экземпляр класса
print(c.func3(24, 5))  # Вызываем статический метод внутри класса


# У статического метода нет параметра self. Это означает, что внутри статического метода
# нет доступа к атрибутам и методам экземплярам класса.
# Методы класса создаются с помощью декоратора @classmethod. В качестве первого параметра
# в метод класса передается ссылка на класс

# <Название класса>.<Название метода>(<Параметры>)

# Также можно вызвать метод класса через экземпляр класса

# <Экземпляр класса>.<Название метода>(<Параметры>)

class MyClass:
    @classmethod
    def func(cls, x):  # Метод класса
        print(cls, x)


MyClass.func(10)  # Вызываем метод через название класса
c = MyClass()
c.func(50)  # Вызываем метод через экземпляр класса


# Абстрактные методы содержат только определение метода без реализации.
# Предполагается, что производный класс должен переопределить метод и реализовать его функциональность
# Чтобы такое преположение сделать более очевидным, часто внутри абстрактного метода возбуждается исключение

class Class1:
    def func(self, x):  # Абсрактный метод
        # Возбуждаем исключение с помощью raise
        raise NotImplementedError('Необходимо переопределить метод')


class Class2(Class1):  # Наследуем абстрактный метод
    def func(self, x):  # Переопределяем метод
        print(x)


class Class3(Class1):  # Класс не переопределяет метод
    pass


c2 = Class2()
c2.func(50)  # >> 50
c3 = Class3()
try:  # Перехватываем исключение
    c3.func(50)  # Ошибка, метод func() не переопределили
except NotImplementedError as msg:
    print(msg)  # >> 'Необходимо переопределить метод'


# В состав стандартной библиотеки входит модуль abc. В этом модуле определен декоратор
# @abstractmethod, который позволяет указать, что метод, перед которым расположен декоратор,
# является абстрактным. При попытке создать экземпляр производного класса, в котором не
# переопределен абстрактный метод, возбуждается исключение TypeError.

# Ограничение доступа к идентификаторам внутри класса.
# Все идентификаторы внутри класса являются открытыми, то есть доступны для изменения
# Для имитации частных идентификаторов можно воспользоваться методами
# __getattr__(), __getattribute__(), __setattr__(), которые перехватывают обращения
# к атрибутам класса. Кроме того можно воспользоваться идентификаторами, названия
# которых начинаются с двух символов подчеркивания. Такие идентификаторы называют ПСЕВДОЧАСТНЫМИ.
# Псевдочастные идентификаторы доступны только ВНУТРИ КЛАССА. Тем не менее
# изменить идентификатор через экземпляр класса все равно можно

class MyClass:
    def __init__(self, x):
        self.__privateVar = x

    def set_var(self, x):  # Изменение значения
        self.__privateVar = x

    def get_var(self):  # Получение значения
        return self.__privateVar


c = MyClass(10)  # Создаем экземпляр класса
print(c.get_var())  # >> 10
c.set_var(20)  # Изменяем значение
print(c.get_var())  # >> 20
try:  # Перехватываем ошибки
    print(c.__privateVar)  # Ошибка!!! Нельзя узнать значение псевдочастного атрибута
except AttributeError as msg:
    print(msg)

c._MyClass__privateVar = 50  # Значение псевдочастных атрибутов можно изменить!

print(c.get_var())  # >> 50


# Можно также ограничить перечень атрибутов, разрешенных для экземпляра класса.
# Для этого разрешенные атрибуты указываются внутри класса в атрибуте __slots__.
# Если производится попытка обращения к атрибуту, не указанному в __slots__,
# возбуждается исключение AttributeError
class MyClass:
    __slots__ = ['x', 'y']

    def __init__(self, a, b):
        self.x, self.y = a, b


c = MyClass(1, 2)
print(c.x, c.y)
c.x, c.y = 10, 20
print(c.x, c.y)

try:
    c.z = 50  # Атрибут z не указан в __slots__
except AttributeError as msg:
    print(msg)


# Свойства класса
# Внутри класса можно создать идентификатор, через который в дальнейшем будут производиться
# операции получения и изменения значения какого-либо атрибута, а также его удаления.
# Создается такой идентификатор с помощью функции property(). Формат функции:
# <Свойство> = property(<Чтение>[, <Запись>[, <Удаление>
#                       [, <Строка документирования>]]])
# Если в качестве какого-либо параметра задано значение None, то это означает, что
# соответствующий метод не поддерживается

class MyClass:
    def __init__(self, value):
        self.__var = value

    def get_var(self):
        return self.__var

    def set_var(self, value):
        self.__var = value

    def del_var(self):
        del self.__var

    v = property(get_var, set_var, del_var, 'Строка документирования')


c = MyClass(5)
c.v = 35
print(c.v)
del c.v


# Также имеется альтернативный метод определения свойств - с помощью методов
# getter(), setter(), deleter(), которые используются в декораторах.
class MyCLass:
    def __init__(self, value):
        self.__var = value

    @property
    def v(self):
        return self.__var

    @v.setter
    def v(self, value):
        self.__var = value

    @v.deleter
    def v(self):
        del self.__var


c = MyClass(5)
c.v = 35
print(c.v)
del c.v


# Декораторы классов, позволяют изменить поведение самих классов.
# В качестве параметров декоратор принимает ссылку на объект класса, поведение которого
# необходимо изменить, и должен возвращать ссылку на тот же класс или какой-либо другой.
def deco(C):  # Принимает объект класса
    print('Внутри декоратора')  # Производит какие-то действия
    return C  # Возвращает объект класса
@deco
class MyClass:
    def __init__(self, value):
        self.v = value
c = MyClass(5)
print(c.v)