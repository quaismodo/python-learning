# Списки, кортежи, множества и диапазоны

# Списки, кортежи, множества и диапазоны - это нумерованные наборы объектов.
# Каждый элемент содержит лишь ссылку на объект - поэтому они могут содержать
# объекты произвольного типа и иметь неограниченную степень вложенности.

# Списки и кортежи являются просто упорядоченными последовательностями элементов.
# Как и все последовательности, они поддерживают обращение к элементу по индексу,
# получение среза и т.д.

# Списки отностятся к изменяемым типам.
arr = [1, 2, 3]
print(arr[0])  # >> 1
arr[0] = 50
print(arr)  # >> [50, 2, 3]

# Кортежы относятся к неизменяемым типам данных.
t = (1, 2, 3)
print(t[0])  # >> 1
# t[0] = 50 # >> Приведет к ошибке! Изменить элемент кортежа по индексу нельзя!

# Множества могут быть как изменяемыми, так и неизменяемыми.
# Их основное отличие от только что рассмотренных типов данных -
# - хранение лишь уникальных значений (неуникальные автоматически отбрасываются)
print(set([0, 1, 1, 2, 3, 3, 4]))  # >> {0, 1, 2, 3, 4}

# Что касается диапазонов, то они представляют собой наборы чисел,
# сформированные на основе заданных начального, конечного значения и величины шага.
# Их важнейшее преимущество перед остальными наборами объектов - небольшой объем
# занимаемой оперативной памяти
r = range(0, 101, 10)  # 101 не включается в диапазон, последним элементов будет 100
for i in r: print(i, end=' ')  # >> 0 10 20 30 40 50 60 70 80 90 100
print()

# Не рекомендуется использовать групповое присваивание для списков!
x = y = [1, 2]  # Якобы создали 2 объекта
print(x, y)  # >> [1, 2] [1, 2]

# Теперь изменим значение переменной y
y[1] = 100
print(x, y)  # >> [1, 100] [1, 100]

# Обе переменные ссылаются на один объект, поэтому изменилась и переменная x
# Рекомендуется производить раздельное присваивание
x, y = [1, 2], [1, 2]
y[1] = 100
print(x, y)  # >> [1, 2] [1, 100]

# Такая же ситуация возникнет при использовании оператора повторения *.
arr = [[]] * 2  # Якобы создали два вложенных списка
print(arr)  # >> [[], []]
arr[0].append(5)
print(arr)  # >> [[5], [5]]
print(id(arr[0]) == id(arr[1]))  # >> True
# Вложенные списки ссылаются на один объект

# Создать вложенные списки, следует с помощью метода append() внутри цикла:
arr = []
for i in range(2): arr.append([])
print(arr)  # >> [[], []]
arr[0].append(5)
print(arr)  # >> [[5], []]

# Также можно воспользоваться генераторами списков:
arr = [[] for i in range(2)]
print(arr)  # >> [[], []]
arr[0].append(5)
print(arr)  # >> [[5], []]

# Чтобы проверить ссылаются ли две переменные на один объект, используют оператор is
x = y = [1, 2]
print(x is y)  # >> True (переменные содержат ссылку на один и тот же список)

x, y = [1, 2], [1, 2]
print(x is y)  # >> False (переменные ссылаются на разные объекты)

# Что же делать если необходимо создать копию списка?
# Первый способ заключаеься в операции извлечения среза, второй - в использовании функции list(),
# а третий - в вызове метода copy()
x = [1, 2, 3, 4, 5]  # Создали список
# Создаем копию списка
y = list(x)
# или с помощью среза, y = x[:]
# или вызовом метода copy(), y = x.copy()
print(x is y)  # >> False (оператор показывает, что это разные объекты)
y[1] = 100
print(x, y)  # >> [1, 2, 3, 4, 5] [1, 100, 3, 4, 5]

# На первый взляд может показаться что мы получили копию списка.
# Но проблема заключается в том, что списки имеют неограниченную вложенность.
x = [1, [2, 3, 4, 5]]  # Создали вложенный список
y = list(x)  # Якобы сделали копию
print(x is y)  # >> False (разные объекты)
y[1][1] = 100
print(x, y)  # >> [1, [2, 100, 4, 5]] [1, [2, 100, 4, 5]]
# Изменение затронуло переменную x!!!
# Таким образом функция list() и операция извлечения среза создают лишь
# поверхностную копию списка.
print(x[1] is y[1])  # >> True (переменные y и x ссылаются на один и тот же вложенный список)

# Чтобы получить полную копию списка используем функцию deepcopy() из модуля copy()
import copy

x = [1, [2, 3, 4, 5]]
y = copy.deepcopy(x)
y[1][1] = 100
print(x, y)  # >> [1, [2, 3, 4, 5]] [1, [2, 100, 4, 5]]
# Изменился только список в переменной y


# Операции над списками

# Обращение к элементам списка осуществляется с помощью квадратных скобок, в которых
# указывается индекс
arr = [1, 'str', 3.2, '4']
print(arr[0], arr[1], arr[2], arr[3])

# С помощью позиционного присваивания можно присвоить значения элементов списка переменным
x, y, z = [1, 2, 3]
print(x, y, z)
# x, y = [1, 2, 3] # >> Выведет ошибку. Количество элементов должно совпадать!

# При позиционном присваивании перед одной из переменных можно указать звездочку *.
# В этой переменной будет сохраняться СПИСОК, состоящий из "лишних" элементов,
# если таких элементов нет, то списко будет пустым
x, y, *z = [1, 2, 3]
print(x, y, z)
x, y, *z = [1, 2, 3, 4, 5]
print(x, y, z)
x, y, *z = [1, 2]
print(x, y, z)
*x, y, z = [1, 2]
print(x, y, z)
x, *y, z = [1, 2, 3, 4, 5]
print(x, y, z)
*z, = [1, 2, 3, 4, 5]
print(z)

# Получение количества элементов списка
arr = [1, 2, 3, 4, 5]
print(len(arr))

print(arr[len(arr) - 1])  # последний элемент списка

arr[0] = 600  # изменение элемента по индексу
print(arr)

# Еще некоторые операции со списками

m = arr[:]  # Поверхностная копия списка
print(arr[::-1])  # В обратном порядке
print(arr[1:])  # Список без первого элемента
print(arr[:-1])  # Список без последнего элемента
print(arr[0:2])  # Символ с индексом 2 не входи в диапазон
print(arr[-1:])  # Последний элемент списка

arr[1:3] = [6, 7]  # Изменяем значения элементов с индексами 1 и 2
print(arr)
arr[1:3] = []  # Удаляем элементы с индексами 1 и 2
print(arr)
print(2 in [1, 2, 3, 4, 5])  # True (проверка на вхождение)

# Многомерные списки
arr = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
print(arr[1][1])  # >> 5 (чтобы получить элемент во вложенном списке, указываем два индекса)

arr = [[1, {'a': 10, 'b': ["s", 5]}]]
print(arr[0][1]['b'][0])  # >> 's' (количество вложений не ограничено)

# Перебор элементов списка
arr = [1, 2, 3, 4, 5]
for i in arr: print(i, end=' ')
print()

# Если элементы списка имеют не изменяем тип, то изменение переменной i не повлияет на список
for i in arr: i += 10
print(arr)  # Список не изменился

# Элементы имеют изменяемый тип
arr = [[1, 2], [3, 4]]
for i in arr: i[0] += 10
print(arr)  # Список изменился

# С помощью функции range() можно влиять на неизменяемые типы элементов списка,
# путем перебора индексов элементов списка

arr = [1, 2, 3, 4]
for i in range(len(arr)):
    arr[i] *= 2
print(arr)

# Также можно использовать функцию enumerate()
for i, elem in enumerate(arr):
    arr[i] *= 2
print(arr)

# Генераторы список и выражения-генераторы
# С помощью генераторов списков тот же самый код можно записать
# более компактно, к тому же генераторы списков работают быстрее цикла for
arr = [1, 2, 3, 4]
arr = [i * 2 for i in arr]
print(arr)

# В генераторах списков могут встречаться вложенные циклы for и операторы ветвления if
arr = [1, 2, 3, 4]
arr = [i * 10 for i in arr if i % 2 == 0]  # получаем четное число, и умножаем его на 10
print(arr)

arr = [[1, 2], [3, 4], [5, 6]]
arr = [j * 10 for i in arr for j in i if j % 2 == 0]
print(arr)

# Если выражение разместить не в квадратных, а в круглых скобок, то будет
# возвращаться не список, а итератор. Такие конструкции называются выражения-генераторы
arr = [1, 4, 12, 45, 10]
print(sum((i for i in arr if i % 2 == 0)))


# Функции map(), zip(), filter(), reduce()
# Встроенная функция map() позволяет применить заданную в параметре функцию, к каждому
# элементу последовательности
# map(<Функция>, <Последовательность1>[, ..., <ПоследовательностьN>])

def func(elem):
    '''Увеличение значения каждого элемента списка'''
    return elem + 10


arr = [1, 2, 3, 4, 5]
print(map(func, arr))  # Сама функция возвращает объект, поддерживающий итерации
print(list(map(func, arr)))  # Чтобы получить список, используем list()


def func(e1, e2, e3):
    '''Суммирование элементов трех разных списков'''
    return e1 + e2 + e3


arr1 = [1, 2, 3, 4, 5]
arr2 = [10, 20, 30, 40, 50]
arr3 = [100, 200, 300, 400, 500]
print(list(map(func, arr1, arr2, arr3)))

arr1 = [1, 2, 3, 4, 5]
arr2 = [10, 20]
arr3 = [100]
print(list(map(func, arr1, arr2, arr3)))  # Если списки разные по длине, за основу берется
# последовательность с минимальном количество элементов

# Функция zip() на каждой итерации возвращает кортеж, содержащий элементы последовательностей,
# которые расположены на одинаковом смещении
print(list(zip([1, 2, 3], [4, 5, 6], [7, 8, 9])))

# Функция filter() позволяет выполнить проверку элементов последовательности
# Если в первом параментре вместо названия функции, указать значение None, то
# каждый элемент будет проверен на соответствие значению True
# элементы вернувшие False, не будут добавлены в результат
print(list(filter(None, [1, 0, None, [], 2])))


def func(elem):
    return elem >= 0


arr = [-1, 2, -3, 4, -20, 10]
arr = list(filter(func, arr))
print(arr)  # >> [2, 4, 10] (выведет числа больше 0)

# Функция reduce() из модуля functools применяет указанную функциию к парам элементов
# и накапливает результат.

from functools import reduce


def func(x, y):
    print("{0} + {1} =".format(x, y), end=' ')
    return x + y


arr = [1, 2, 3, 4, 5]
summa = reduce(func, arr)
print(summa)

# Добавление и удаление элементов списка
# Для добавления и удаления элементов спичка используются следующие методы:
arr = [1, 2, 3]
arr.append(4)
print(arr)  # Добавили элемент 4 в конец списка
arr.append([5, 6])
print(arr)  # Добавили вложенный список

# метод extend() добавляет элементы последовательности в конец списка
arr.extend([4, 5, 6])
print(arr)  # добивили элементы списка в список arr
# также можно добавить элементы списка конкатенацией или присваиванием срезу
arr += [7, 8, 9]
print(arr)
arr[len(arr):] = [10, 11, 12]
print(arr)

# insert(<Индекс>, <Объект>) добавляет ОДИН объект в указанную позицию, остальные элементы смещаются
arr.insert(0, 0)
print(arr)  # добавили элемент 0 в 0 позицию списка

# pop([<Индекс>]) - удаляет элемент, расположенный по указанному индексу, и возвращает его
# если индекс не указан, то удаляет последний элемент списка и возвращает его
last_symbol = arr.pop()  # удаляем символ из списка и присваиваем его переменной
print(arr)
print(last_symbol)
first_symbol = arr.pop(0)  # удаляем первый элемент и присваиваем
print(arr)
print(first_symbol)

# remove(<Значение>) - удаляет первый элемент, содержащий указанное значение (НЕ ИНДЕКС).
# Метод ничего не возвращает, а только изменяет список
arr.remove(1)  # удаляем 1 из списка
print(arr)

# clear() - удаляет все элементы списка, очищая его.
arr.clear()
print(arr)

# если необходимо удалить повторяющиеся элементы, то можно преобразовать список во множество,
# а затем множество в список
arr = [1, 2, 3, 1, 1, 2, 2, 3, 3]
s = set(arr)
print(s)
arr = list(s)
print(arr)

# Поиск элемента в списке и получение сведений о значениях, входящих в список
# index(<Значение>[, <Начало>[, <Конец>]]) возвращает индекс элемента, имеющего данное значение.
# Если значение не входит в список, то возбуждается исключение ValueError

arr = [1, 2, 1, 2, 1]
print(arr.index(1), arr.index(2))

print(arr.count(1))  # count() ищет количество элементов в списке с указанным значением
print(arr.count(4))  # если элемент не входит в список, возвращает 0

# max(), min() возвращает максимальное и минимальное значение списка
print(max(arr), min(arr))

# Функция any(<Последовательность>) возвращает значение True, если в последовательности
# существует хотя бы один элемент, который возвращает True
print(any([0, None]))
print(any([0, None, 1]))

# Функция all(<Последовательность>) возвращает True, если все элементы списка,
# возвращают True, или последовательность не содержит элементов
print(all([0, None]), all([0, None, 1]), all([]), all(['str', 10]))

# Переворачивание и перемешивание списка
# Метод reverse() изменяет порядок следования элементов на противоположный
arr = [1, 2, 3, 4, 5]
arr.reverse()  # Изменяет текущий список
print(arr)

# Если необходимо изменить порядок и получить новый список,
# используют reversed(<Последовательность>)
arr = [1, 2, 3, 4, 5, 6, 7, 8]
print(reversed(arr))  # Создает новый объект
print(list(reversed(arr)))  # Преобразуем его в список

# Функция shuffle(<Список>[, <Число от 0.0 до 1.0>]) из модуля random
# перемешивает список случайным образом. Функция перемешивает сам список, ничего не возвращая
import random

random.shuffle(arr)
print(arr)

# Выбор элементов случайным образом
# choice(<Последовательность>) - возвращает случаный элемент из любой последовательности
print(random.choice(arr))

# sample(<Последовательность>, <Количество элементов>) - возвращает список из
# указанного количества элементов. В список попадают элементы из последовательности,
# выбранные случайным образом
print(random.sample(arr, 4))

# Сортировка списка
# sort([key=None][, reverse=False]). Метод изменяет текущий список и ничего не возвращает
arr.sort()
print(arr)

# чтобы отсортировать список по убыванию указываем параметру reverse значение True
arr.sort(reverse=True)
print(arr)

# В параметре key можно указать функцию, выполняющую какое-либо действие над каждым
# элементов списка
arr = ['единица1', 'Единый', 'Единица2']
arr.sort()
print(arr)  # >> ['Единица2', 'Единый', 'единица1']
arr.sort(key=str.lower)  # указываем метод lower() который преобразует элементы в нижний регистр
print(arr)  # >> ['единица1', 'Единица2', 'Единый']

# Если необходимо получить новый отсортированный список, а текущий оставить без изменений,
# тогда используется функция sorted(<Последовательность>[, key=None][, reverser=False])
arr = [2, 7, 10, 4, 6]
print(arr.sort())  # >> None
print(sorted(arr))  # >> [2, 4, 6, 7, 10]

# Заполнение списка числами
print(list(range(10)))  # Создаст список от 0 до 9
# также можно воспользоваться методом sample(), для получения рандомных значений

# Преобразование списка в строку
# Преобразовать список в строку позволяет метод join()
# <Строка> = <Разделитель>.join(<Последовательность>)
arr = ['word1', 'word2', 'word3']
arr_str = '-'.join(arr)
print(arr_str)  # >> word1-word2-word3

# Элементы внутри списка должны быть строками иначе возвращается исключение TypeError
# Чтобы избежать исключение, можно использовать выражение-генератор
arr = ['word1', 'word2', 'word3', 1]
arr_str = '-'.join((str(i) for i in arr))  # Преобразуем каждый элемент списка в строку
print(arr_str)  # Получаем строку, несмотря на то что в списке было число

# Кортежи
# Кортежи во многом аналогичны спискам, но есть отличие - изменить кортеж НЕЛЬЗЯ!
# С помощью функции tuple([<Последовательность>]) можно создать кортеж, если параметр не указан
# будет создан пустой кортеж
print(tuple())  # >> ()
print(tuple('String'))  # >> ('S', 't', 'r', 'i', 'n', 'g')

# При создании не пустого кортежа, формируют кортеж ЗАПЯТЫЕ, а не СКОБКИ
t1 = ()  # Пустой кортеж
t2 = (5,)  # Кортеж из одного элемента
t3 = (1, 2, 3, (3, 4))  # Кортеж из четырех элементов
t4 = 1, 2, 3, (3, 4)  # Тоже кортеж из четырех элементов (скобки не обязательны)
t = (5)  # Данная запись не является кортежем, так как кортеж формируют ЗАПЯТЫЕ!
print(type(t))  # >> <class 'int'>
t = 5,  # Кортеж
print(type(t))  # >> <class 'tuple'>

# В остальном кортежи поддерживают обращеие по индексу, конкатенацию, срез,
# проверка на вхождение и невхождение. НО КОРТЕЖИ НЕЛЬЗЯ ИЗМЕНИТЬ!

# Множества
# Множество - это НЕУПОРЯДОЧЕННАЯ последовательность УНИКАЛЬНЫХ элементов.
# Объявляется множество функцией set()
s = set()
print(type(s))  # >> <class 'set'>
print(set('Tamagochi'))
print(set((1, 2, 3, 5, 6)))

# | и union() - объединяют два множества
s = set([1, 2, 3])
print(s.union(set([4, 5, 6])), s | set([4, 5, 6]))
print(s.union([1, 2, 3]))  # >> {1, 2, 3} (если элемент уже содержится, то повторно он добавлен не будет)

# a |= b и a.update(b) - добавляют элементы множества b во множество a
s = set([1, 2, 3])
s.update(set([5, 6, 7]))
print(s)

# Для работы с множествами предназначены следующие методы
# copy() - создает копию множества. Оператор присваивания =, создает лишь ссылку на тот же объект!
s = set([1, 2, 3])
c = s
print(s is c) # >> True (переменные ссылаются на один объект)
c = s.copy()
print(s is c) # >> False (теперь это разные объекты)

# add(<Элемент>) - добавляет элемент во множество
s.add(4)
print(s)
s.add(1) # Если попытаться добавить уже имеющийся элемент, результат останется тот же
print(s)

# remove(<Элемент>) - удаляет элемент если он присутствует, иначе KeyError
# discard(<Элемент>) - удаляет элемент из множества, если его нет, ничего не происходит

print(s.discard(5))
print(s) # Элемент 5 отсутствует, множество осталось тем же
# pop() удаляет ПРОИЗВОЛЬНЫЙ элемент из множества и возвращает его
# clear() удаляет все элементы из множества

# Python также поддерживает тип множеств - frozenset(). В отличии от типа set(),
# множества типа frozenset нельзя изменить

# Диапазоны
# Важнейшим преимущество диапазонов является то тчо они всегда занимают один и тот
# же ОБЪЕМ оперативной памяти.
# для создания диапазона применяется функция range()

# Модуль itertools содержить функции, позволяющие генерировать различные последовательности
# на основе других последовательностей. Все функции возвращают объекты, поддерживающие
# итерации. Для работы необходимо подключить модуль import itertools